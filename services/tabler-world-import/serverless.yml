service: tabler-world-import

plugins:
  - serverless-iam-roles-per-function
  - serverless-plugin-aws-alerts
  - serverless-dynamodb-local
  - serverless-offline
  - serverless-webpack

custom:
  # Our stage is based on what is passed in when running serverless
  # commands. Or fallsback to what we have set in the provider section.
  stage: ${opt:stage, self:provider.stage}

  webpack:
    keepOutputDirectory: true
    packager: "yarn"
    includeModules:
      forceInclude:
        - graphql

      forceExclude:
        - aws-sdk

  email: ${env:ALERT_EMAIL}
  cache_table: tabler-world-cache-${self:custom.stage}
  cache_version: "1.3#v3"
  sqs: ${self:service}-cacheupdates-${self:custom.stage}
  sqs_geo: ${self:service}-geocode-${self:custom.stage}

  # import schedule
  # cron
  cron_rate:
    dev: # disabled, 1
      inc:
        rti: cron(0 0 * * ? *)
        lci: cron( 0 * * ? *)
        c41: cron(20 0 * * ? *)
        act: cron(30 0 * * ? *)

      clubs:
        rti: cron(30 0 * * ? *)
        lci: cron(35 0 * * ? *)
        c41: cron(40 0 * * ? *)
        act: cron(45 0 * * ? *)

      structure:
        rti: cron(45 0 * * ? *)
        lci: cron(50 0 * * ? *)
        c41: cron(55 0 * * ? *)
        act: cron(59 0 * * ? *)

      archived:
        rti: cron(57 1 * * ? *)
        lci: cron(58 1 * * ? *)
        c41: cron(59 1 * * ? *)
        act: cron(30 0 * * ? *)

    test: # disabled
      inc:
        rti: cron(0 1 * * ? *)
        lci: cron(20 1 * * ? *)
        c41: cron(40 1 * * ? *)
        act: cron(30 0 * * ? *)

      clubs:
        rti: cron(0 2 * * ? *)
        lci: cron(20 2 * * ? *)
        c41: cron(40 2 * * ? *)
        act: cron(30 0 * * ? *)

      structure:
        rti: cron(45 2 * * ? *)
        lci: cron(50 2 * * ? *)
        c41: cron(55 2 * * ? *)
        act: cron(30 0 * * ? *)

      archived:
        rti: cron(50 1 * * ? *)
        lci: cron(53 1 * * ? *)
        c41: cron(59 1 * * ? *)
        act: cron(30 0 * * ? *)

    prod:
      inc:
        rti: cron(0 3-20 * * ? *)
        lci: cron(20 3-20 * * ? *)
        c41: cron(40 3-20 * * ? *)
        act: cron(30 0 * * ? *)

      clubs:
        rti: cron(0 21 * * ? *)
        lci: cron(20 21 * * ? *)
        c41: cron(40 21 * * ? *)
        act: cron(30 0 * * ? *)

      structure:
        rti: cron(0 22 * * ? *)
        lci: cron(20 22 * * ? *)
        c41: cron(40 22 * * ? *)
        act: cron(30 0 * * ? *)

      archived:
        rti: cron(15 23 * * ? *)
        lci: cron(35 23 * * ? *)
        c41: cron(45 23 * * ? *)
        act: cron(30 0 * * ? *)

  cron_enabled:
    dev: false
    test: true
    prod: true

  bundle:
    dev: false
    test: true
    prod: true

  # SNS topics to check env
  alerts:
    stages:
      - test
      - prod

    topics:
      alarm:
        topic: ${self:service}-${self:custom.stage}-alerts-alarm
        notifications:
          - protocol: email
            endpoint: ${self:custom.email}

    alarms:
      - functionErrors
      - processTimeouts

    definitions:
      processTimeouts:
        metric: processTimeouts
        threshold: 0
        statistic: Minimum
        period: 60
        evaluationPeriods: 1
        comparisonOperator: GreaterThanThreshold
        pattern: "Process exited before completing"

  # debug mode
  dynamodb:
    noStart: false

    start:
      # host: localhost
      port: 8000
      sharedDb: true
      migrate: true
      seed: false
      inMemory: true

    stages:
      - dev

# we want seperate files to minimize depenencies in files
package:
  individually: ${self:custom.bundle.${self:custom.stage}}

provider:
  name: aws
  stage: dev
  region: eu-west-1

  runtime: nodejs12.x

  deploymentBucket:
    name: tabler-world-deployments
    maxPreviousDeploymentArtifacts: 5
    blockPublicAccess: true
    serverSideEncryption: AES256

  memorySize: 128
  versionFunctions: false

  # allow to redefine variables for debug purposes
  environment: ${file(serverless.env.yml):${self:custom.stage}}

  vpc: ${file(../devops/vpc.yml):lambda}

  # global role definition
  iamRoleStatements:
    # read parameters from SSM
    - Effect: Allow
      Action:
        - ssm:GetParameters
        - ssm:GetParameter
      Resource:
        Fn::Join:
          - ""
          - - "arn:aws:ssm:"
            - ${self:provider.region}
            - ":"
            - Ref: "AWS::AccountId"
            - ":parameter*/"
            - ${self:custom.stage}
            - "/*"

    # tracing AWSXrayWriteOnlyAccess
    - Effect: Allow
      Action:
        - xray:PutTraceSegments
        - xray:PutTelemetryRecords
        - xray:GetSamplingRules
        - xray:GetSamplingTargets
        - xray:GetSamplingStatisticSummaries

      Resource:
        - "*"

functions:
  #
  # Import reader
  #
  reader:
    handler: src/reader/lambda.handler
    timeout: 840
    tracing: Active

    environment:
      sqs_queue:
        Ref: ReadUpdatesQueue
      readerservice_arn:
        Fn::Join:
          - ""
          - - "arn:aws:lambda:"
            - ${self:provider.region}
            - ":"
            - Ref: "AWS::AccountId"
            - ":function:"
            - "tabler-world-import-"
            - ${self:custom.stage}
            - "-reader"

      XRAY_DISABLED: false

    iamRoleStatementsInherit: true
    iamRoleStatements:
      - Effect: Allow
        Action:
          - sqs:SendMessage
          - sqs:SendMessageBatch
        Resource:
          Fn::GetAtt:
            - ReadUpdatesQueue
            - Arn

      # allow self execution
      - Effect: "Allow"
        Action:
          - "lambda:InvokeFunction"
        Resource:
          Fn::Join:
            - ""
            - - "arn:aws:lambda:"
              - ${self:provider.region}
              - ":"
              - Ref: "AWS::AccountId"
              - ":function:"
              - "tabler-world-import-"
              - ${self:custom.stage}
              - "-reader"

    events:
      - schedule:
          name: ${self:service}-rti-members-${self:custom.stage}
          description: Update members from TABLER.WORLD

          rate: ${self:custom.cron_rate.${self:custom.stage}.inc.rti}
          enabled: ${self:custom.cron_enabled.${self:custom.stage}}

          input:
            target: rti
            type: members
            mode: incremental
            offset: 0
            maxRecords: 4000

      - schedule:
          name: ${self:service}-lci-members-${self:custom.stage}
          description: Update members from CIRCLER.WORLD

          rate: ${self:custom.cron_rate.${self:custom.stage}.inc.lci}
          enabled: ${self:custom.cron_enabled.${self:custom.stage}}

          input:
            target: lci
            type: members
            mode: incremental
            offset: 0
            maxRecords: 4000

      - schedule:
          name: ${self:service}-rti-clubs-${self:custom.stage}
          description: Update clubs from TABLER.WORLD

          rate: ${self:custom.cron_rate.${self:custom.stage}.clubs.rti}
          enabled: ${self:custom.cron_enabled.${self:custom.stage}}

          input:
            target: rti
            mode: full
            type: clubs
            offset: 0
            maxRecords: 4000

      - schedule:
          name: ${self:service}-lci-clubs-${self:custom.stage}
          description: Update clubs from CIRCLER.WORLD

          rate: ${self:custom.cron_rate.${self:custom.stage}.clubs.lci}
          enabled: ${self:custom.cron_enabled.${self:custom.stage}}

          input:
            target: lci
            mode: full
            type: clubs
            offset: 0
            maxRecords: 4000

      - schedule:
          name: ${self:service}-rti-structure-${self:custom.stage}
          description: Updates structure from TABLER.WORLD

          rate: ${self:custom.cron_rate.${self:custom.stage}.structure.rti}
          enabled: ${self:custom.cron_enabled.${self:custom.stage}}

          input:
            target: rti
            mode: full
            type: structure
            noRefreshViews: true
            noUpdateCache: true

      - schedule:
          name: ${self:service}-lci-structure-${self:custom.stage}
          description: Updates structure from CIRCLER.WORLD

          rate: ${self:custom.cron_rate.${self:custom.stage}.structure.lci}
          enabled: ${self:custom.cron_enabled.${self:custom.stage}}

          input:
            target: lci
            mode: full
            type: structure
            noRefreshViews: true
            noUpdateCache: true

      - schedule:
          name: ${self:service}-rti-members-archived-${self:custom.stage}
          description: Remove archived members from TABLER.WORLD

          rate: ${self:custom.cron_rate.${self:custom.stage}.archived.rti}
          enabled: ${self:custom.cron_enabled.${self:custom.stage}}

          input:
            target: rti
            mode: incremental
            type: archivedMembers

      - schedule:
          name: ${self:service}-lci-members-archived-${self:custom.stage}
          description: Remove archived members from CIRCLER.WORLD

          rate: ${self:custom.cron_rate.${self:custom.stage}.archived.lci}
          enabled: ${self:custom.cron_enabled.${self:custom.stage}}

          input:
            target: lci
            mode: incremental
            type: archivedMembers

      # 41 International
      - schedule:
          name: ${self:service}-c41-members-${self:custom.stage}
          description: Update members from 41ER.WORLD

          rate: ${self:custom.cron_rate.${self:custom.stage}.inc.c41}
          enabled: ${self:custom.cron_enabled.${self:custom.stage}}

          input:
            target: c41
            type: members
            mode: incremental
            offset: 0
            maxRecords: 4000

      - schedule:
          name: ${self:service}-c41-clubs-${self:custom.stage}
          description: Update clubs from 41ER.WORLD

          rate: ${self:custom.cron_rate.${self:custom.stage}.clubs.c41}
          enabled: ${self:custom.cron_enabled.${self:custom.stage}}

          input:
            target: c41
            mode: full
            type: clubs
            offset: 0
            maxRecords: 4000

      - schedule:
          name: ${self:service}-c41-structure-${self:custom.stage}
          description: Updates structure from 41ER.WORLD

          rate: ${self:custom.cron_rate.${self:custom.stage}.structure.c41}
          enabled: ${self:custom.cron_enabled.${self:custom.stage}}

          input:
            target: c41
            mode: full
            type: structure
            noRefreshViews: true
            noUpdateCache: true

      - schedule:
          name: ${self:service}-c41-members-archived-${self:custom.stage}
          description: Remove archived members from 41ER.WORLD

          rate: ${self:custom.cron_rate.${self:custom.stage}.archived.c41}
          enabled: ${self:custom.cron_enabled.${self:custom.stage}}

          input:
            target: c41
            mode: incremental
            type: archivedMembers
  #
  # Cache update
  #
  cache:
    handler: src/cache/lambda.handler
    timeout: 60
    memorySize: 128
    reservedConcurrency: 3
    tracing: Active

    environment:
      CACHE_TABLE: ${self:custom.cache_table}
      XRAY_DISABLED: false
      geocode_queue:
        Ref: EncodeAddressQueue

    iamRoleStatementsInherit: true
    iamRoleStatements:
      - Effect: Allow
        Action:
          - dynamodb:DescribeTable
          - dynamodb:Query
          - dynamodb:Scan
          - dynamodb:GetItem
          - dynamodb:PutItem
          - dynamodb:UpdateItem
          - dynamodb:DeleteItem
          - dynamodb:BatchGetItem
          - dynamodb:BatchWriteItem

        Resource:
          - "Fn::GetAtt": [graphqlsqTable, Arn]

      - Effect: Allow
        Action:
          - sqs:SendMessage
          - sqs:SendMessageBatch
        Resource:
          Fn::GetAtt:
            - EncodeAddressQueue
            - Arn

    events:
      - sqs:
          arn:
            Fn::GetAtt:
              - ReadUpdatesQueue
              - Arn

  warmup:
    handler: src/warmup/lambda.handler
    timeout: 300
    memorySize: 128

    environment:
      CACHE_TABLE: ${self:custom.cache_table}
      XRAY_DISABLED: true

  #
  # Cache update
  #
  geocode:
    handler: src/geocode/lambda.handler
    timeout: 120 # batchSize 1, elements 10
    memorySize: 128
    reservedConcurrency: 1
    tracing: Active

    environment:
      geo_agent: ${self:custom.geo_agent}
      geo_email: ${self:custom.geo_email}
      sqs_arn:
        Fn::GetAtt:
          - EncodeAddressQueue
          - Arn
      XRAY_DISABLED: false

    iamRoleStatementsInherit: true
    iamRoleStatements:
      - Effect: Allow
        Action:
          - lambda:ListEventSourceMappings
          - lambda:UpdateEventSourceMapping
        Resource: "*"

    events:
      - sqs:
          arn:
            Fn::GetAtt:
              - EncodeAddressQueue
              - Arn
          batchSize: 1

resources:
  Resources:
    readerAsyncConfig:
      Type: AWS::Lambda::EventInvokeConfig
      Properties:
        FunctionName:
          Ref: ReaderLambdaFunction
        MaximumRetryAttempts: 0
        Qualifier: $LATEST

    graphqlsqTable:
      Type: AWS::DynamoDB::Table
      DeletionPolicy: Delete
      Properties:
        BillingMode: PAY_PER_REQUEST
        TableName: ${self:custom.cache_table}
        AttributeDefinitions:
          - AttributeName: id
            AttributeType: S

        KeySchema:
          - AttributeName: id
            KeyType: HASH

        TimeToLiveSpecification:
          AttributeName: ttl
          Enabled: true

    ReadUpdatesQueue:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: ${self:custom.sqs}
        MessageRetentionPeriod: 1209600
        # 6 times lambda timeout
        VisibilityTimeout: 60
        RedrivePolicy:
          deadLetterTargetArn:
            Fn::GetAtt:
              - ReadUpdatesQueueDeadLetters
              - Arn
          maxReceiveCount: 5

    ReadUpdatesQueueDeadLetters:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: ${self:custom.sqs}-dead
        MessageRetentionPeriod: 1209600
        VisibilityTimeout: 0

    EncodeAddressQueue:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: ${self:custom.sqs_geo}
        MessageRetentionPeriod: 1209600
        # 6 times lambda timeout
        VisibilityTimeout: 720
        RedrivePolicy:
          deadLetterTargetArn:
            Fn::GetAtt:
              - EncodeAddressQueueDeadLetters
              - Arn
          maxReceiveCount: 5

    EncodeAddressQueueDeadLetters:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: ${self:custom.sqs_geo}-dead
        MessageRetentionPeriod: 1209600
        VisibilityTimeout: 0

    GeocodeLogGroup:
      Properties:
        RetentionInDays: "7"

    CacheLogGroup:
      Properties:
        RetentionInDays: "7"

    ReaderLogGroup:
      Properties:
        RetentionInDays: "7"

    WarmupLogGroup:
      Properties:
        RetentionInDays: "7"

  Outputs:
    CacheTableArn:
      Value:
        Fn::GetAtt:
          # functions are renamed acording to https://github.com/serverless/serverless/blob/master/docs/providers/aws/guide/resources.md
          - graphqlsqTable
          - Arn
      Export:
        Name: CacheTableArn-${self:custom.stage}

    CacheVersion:
      Value: ${self:custom.cache_version}

      Export:
        Name: CacheVersion-${self:custom.stage}

    CacheTableName:
      Value: ${self:custom.cache_table}

      Export:
        Name: CacheTableName-${self:custom.stage}
